---
title: A Cognitive Dimensions analysis of interaction design for algorithmic composition software
author:
 - Matt Bellingham
 - Simon Holland
 - Paul Mulholland
keywords: POP-I.C. end-user applications, POP-II.B. design, POP-III.C. Cognitive Dimensions, POP-IV.B. user interfaces, POP-V.A. theories of design, POP-VI.F. exploratory
bibliography: /Users/matt/Documents/Research/bib/oldbibJan17.bib
csl: /Users/matt/Documents/Research/bib/the-open-university-harvard.csl
---


# Abstract {-}

This paper presents an analysis of the user interfaces of a range of algorithmic music composition software using the Cognitive Dimensions of Notations as the main analysis tool. Findings include the following: much of the reviewed software exhibits a low viscosity and requires significant user knowledge. The use of metaphor (staff notation, music production hardware) introduces multiple levels of abstraction which the user has to understand in order to use effectively: some instances of close mapping reduce abstraction but require the user to do more work. Significant premature commitment is not conducive to music composition, and there are clear opportunities for the greater provisionality that a piece of structurally-aware music software could provide. Visibility and juxtaposability are frequently compromised by complex design. Patching software reduces the hard mental operations required of the user by making the signal flow clear, although graphical complexity can have a negative impact on role-expressiveness. Complexity leads to error-proneness in several instances, although there are some tools (such as error-checking and auto-completion) which seek to ameliorate the main problems.


# Introduction

This paper presents an analysis, using the Cognitive Dimensions of Notations [@Green:1998aa], of a representative selection of user interfaces for algorithmic music composition software. Cognitive Dimensions of Notations (CDN) are design principles for notations, user interfaces and programming language design, or from another viewpoint 'discussion tools' for designers [@Green:1998aa]. For the purposes of this report, algorithmic composition software is software which generates music using computer algorithms, where the algorithms may be controlled by end users (who may variously be considered as composers or performers). For example, the algorithms may be created by the end user, or the user may provide data or parameter settings to pre-existing algorithms. Other kinds of end-user manipulation are also possible. The software accepts either precise or imprecise, indicative input from the user which is used to output music via emergent behaviour. A wide variety of algorithmic composition software is considered, including visual programming languages, text-oriented programming languages, and software which requires or allows data entry by the user. The paper considers a representative, rather than comprehensive, selection of software. The analysis also draws, where appropriate, on related discussion tools drawn from Crampton Smith [@Moggridge:2006aa], @Cooper:2007aa and @Rogers:2011aa. Finally, the paper reflects on the compositional representation of time as a critical dimension of composition software that is implicit in several of the CDNs.

For detailed images from a wide variety of algorithmic composition software illustrating all issues touched on in this paper, see @Bellingham:2014aa, of which this paper is an abbreviated version.


# Structure and connections

Sections, and the connections between them, are an important feature of much music. Several genres of music require a sectional structure (ABA, for example). An interface which matches the user's conceptual structure will reduce both repetition viscosity (caused when the software requires several actions to achieve a single goal) and knock-on viscosity (created when a change is made and the software requires further remedial action to restore the desired operation). @Cooper:2007aa suggest three separate models for the perception of software; the *implementation model* of the software (how it works), the user's *mental model* (how the user imagines the software to work) and the *representational model* of the software (what the software shows the user). Repetition viscosity could be significantly reduced by better matching the mental model to the representational or implementation models. For example, if the implementation model made use of repeating sections the user could apply a change to the section and it would play back correctly both times. If the representational model showed repeating sections (as visual blocks, for example) and then relayed the changed material to all relevant repeats in the implementation layer, the user would input the desired changes once and they would be propagated out to the playback system. This model links to provisionality, which refers to the degree of commitment the user must make to their actions [@Green:1998aa]. It allows users to make imprecise, indicative selections before making definite choices. Provisionality reduces premature commitment as it allows a composer to create sketches before allowing for specific details.

<!-- Paul: I don’t know if the issue here is the mapping to the user’s mental model of the software. I think it is just whether the representational model allows for structural features such as repetition. -->

Some of the software under review allows the software to make selections within a given range. *SuperCollider* makes use of `.coin` and `.choose` messages for this reason; `.coin`, for example, represents a virtual toss of a coin. Other software, such as *Max*, can make use of pseudo-random numbers in parameters; this allows the composer to issue a command such as 'use a value between x and y'. Such selections can increase provisionality in the system (the degree of commitment the user must make to their actions), although more complex variations require significant planning which negates the benefits of being able to quickly create a functional piece of code. DAW software such as *Logic Pro* [@Apple-Inc:2013aa] makes use of audio and MIDI loops to facilitate provisionality in composition and arrangement. Users are able to create sketches using loops, replacing them later in the process. Some music composition software allows the user to create music following basic harmonic or rhythmic parameters. *Noatikl* has preset objects which can be used to create sequences, and *Impro-Visor*'s preset algorithms allow for quick musical sketches based on a chord progression [@Keller:2012aa]. One possible design would allow the user to specify the desired structure and then populate the sections. Repeated sections would require two 'pools' of information; those attributes common to both, and those for that specific iteration.

<!-- Image removed due to space constraints
![Possible layout allowing common material to be shared between sections](https://dl.dropboxusercontent.com/u/145228/Research/Images/interaction-design/aba.png)
-->

Most software in the domain allows links to be made only between pre-existing entities. In these cases the user is unable to say 'I don't know what is going here', which can be a useful option when composing. One possible solution to this problem would be to decouple the design of the patch/composition from the actualisation. This could take the form of a graphical sketching tool which would allow the user to test the structure and basic design of the patch.

<!-- Image removed due to space constraints
![Potential layout for structure-aware composition software](https://dl.dropboxusercontent.com/u/145228/Research/Images/interaction-design/unknown.png)
-->

The role-expressiveness of an element relates to how easily the user can infer its purpose [@Green:1998aa]. The use of metaphor (such as mixing desks, synthesisers, piano rolls and staff notation) allows users to quickly understand the potential uses of each editor. Abstractions can be used to make software more effectively match the user's mental model [@Cooper:2007aa]. Multiple steps can be combined to make the software conform to the user's expectations. Such abstractions can make use of a metaphor such as the hardware controls of a tape machine.  Other hardware metaphors are used in current algorithmic composition software. The *Cylob Music System* by Chris Jeffs [-@Jeffs:2010aa] makes use of step-sequencer and drum machine designs, among others.

There are two types of links made in the software under consideration; one-way and symmetric. One-way links send data, whereas symmetric links can both send and receive information. One-way links, such as a send object in *Pure Data* or a variable in *SuperCollider*, do not reflect changes made elsewhere in the system. Visual audio programming systems typically use a patch cable metaphor and, as the majority of physical patching utilises a unidirectional (i.e. audio send or return) rather than bidirectional (i.e. USB) connection, software such as *Max* and *Pure Data* retains a one-way connectivity metaphor. Visual patching systems allow users to see links at the potential expense of increased premature commitment. The patch-cable metaphor used in visual programming languages makes dependencies explicit and reduces the potential for hidden dependencies. In addition, the use of patch cables is an example of closeness of mapping [@Blackwell:2003aa].

Both graphical and text-oriented languages can make use of variables and hidden sends and returns. If users are required to check dependencies before they make changes to the software the search cost is increased. This in turn can lead to higher error rates (via knock-on viscosity). Abstractions can impose additional hidden dependencies; users may not be able to see how changes will affect other elements in the patch. Both *Max* and *Pure Data* allow graphical elements (such as colour, fonts and canvas objects) to be added to patches, enhancing the information available via secondary notation (extra information conveyed to the user in means other than the formal syntax). Graphical languages are substantially more diffuse (verbose) than text-oriented languages, and can make hidden dependencies explicit. Text-oriented languages typically have a lower role-expressiveness  (how easily the user can infer the software's purpose). *ChucK* [@Wang:2013aa] is an interesting hybrid in this respect. Data can be 'chucked' from one object to another using the `=>` symbol, the use of which imitates a patch cable. The other text-oriented languages reviewed do not make direct use of graphical or spatial interconnectivity. In this way *ChucK* makes limited use of Crampton Smith's second dimension of IxD; visual representation [@Moggridge:2006aa].

<!-- Image removed due to space constraints
![An example of the `=>` patching syntax in *ChucK* [@Wang:2013aa]](https://dl.dropboxusercontent.com/u/145228/Research/Images/interaction-design/chuck-fm-example.png)
-->

<!--
There is a balance to be struck in composition software between having too much visual information and not having enough to complete a given task. Key parameters must be made visible without introducing clutter to the design. An example of a high level of both visibility and juxtaposability is the layout of the *Cylob Music System*; several 'layers' of the software allow for multiple parameters to be compared and controlled. Default settings are not always directly visible. *SuperCollider*, for example, has defaults for every unit generator but they are only visible within the help files. The parameters are explicitly visible when the user issues them as methods but the method order (i.e. which parameter is controlled by each command) is again only visible in the help files. An experienced user will memorise the method order but this lack of visibility has an impact on the novice user.
-->

<!-- Image removed due to space constraints
![*Cylob Music System* interface demonstrating both visibility and juxtaposability](http://durftal.com/cms/controls.cms_controls.png)
-->

<!-- Image removed due to space constraints
![*SuperCollider* help file for the `SinOsc` sine oscillator](https://dl.dropboxusercontent.com/u/145228/Research/Images/interaction-design/supercollider-help-file.png)
-->



# Time

The passage of time is highly significant when considering the representation of music. Time is not viewed as a separate entity in Cognitive Dimensions, although it is implicit in some dimensions. @Payne:1993aa reviewed the representations of time in calendars, which primarily focussed on the use of horizontal and vertical spatial information to imply the passage of time: in many cases a similar approach can be taken by music software. Sequencers, such as *Cubase* [@Steinberg-Media-Technologies-GmbH:2015aa], frequently use horizontal motion from left to right to denote the passage of time. Trackers, such as *Renoise* [@Impressum:2015aa], frequently show the passage of time as a vertical scroll from top to bottom. Live coding software can present alternative representations of time, as seen in software such as *ixi lang* [@Magnusson:2014aa], *Overtone* [@Aaron:2011aa] and *Tidal* [@McLean:2014aa].

Much musical software makes use of cyclic time (loops), as well as linear time. Both of these kinds of time can be sequenced, or mixed, or arranged hierarchically at different scales, or arranged in parallel streams, or all of these at once. *Tidal*, for example, has been developed to allow the representation of linear and cyclic time simultaneously [@Blackwell:2014aa]. Software written to perform loop-based music frequently uses a different interface to denote the passage of time. *Live* [@Ableton:2014aa] makes use of horizontal time in some interface components; other interface elements allow the user to switch between sample and synthetic content in real-time with no time representation. *Mixtikl* [@Intermorphic:2013aa] is a loop-based system and, in several edit screens, does not show the passage of time at all as the user interacts with the interface.

In a classic paper, Desain and Honing [-@Desain:1993aa] discuss different implicit time structures in tonal music. They point out that, in order to competently speed up piano performances in certain genres, it is no good simply to increase the tempo. While this may be appropriate for structural notes, decorations such as trills tend to need other manipulations such as truncations without speed-ups or substitutions to work effectively at different tempi. Similarly, elements of rhythm at different levels of periodicity, for example periodicities below 200 ms vs. above 2 seconds, may require very different kinds of compositional manipulation since the human rhythm perception (and composers and performers) deal very differently with periodicities in these different time domains [@Angelis:2013aa; @London:2012aa]. In a related sense, @Lerdahl:1983aa uncover four very different sets of time relationships in harmonic structures in tonal music.

Honing [-@Honing:1993aa] differentiates between tacit (i.e. focussed on 'now'), implicit (a list of notes in order) and explicit time structures. Some of the software under review can be considered in this way; for example, some modes of operation in *Mixtikl* and *Live* utilise tacit time structures, the note lists in *Maestro Genesis* and *MusiNum* are implicit time structures, and software such as *Max* or *Csound* can generate material which uses explicit time structures. The flexibility of many of the programming environments under consideration means that the user can determine the timing structures to be used. @Honing:1993aa also applies the same process to structural relations: he suggests that there are tacit, implicit and explicit structural relations. A system which uses explicit structural relations would allow the musical structure to be both declarative and explicitly represented.



# Complexity and stability

<!-- Paul: I am not sure here whether equating viscosity with interface simplicity is correct. My interpretation of viscosity is that a number of possibly repetitive actions need to be taken in order to implement the change as the nature of the representation resists change. Not having the necessary controls to implement the required change would sound to me like a lack of role expressiveness but perhaps I am misunderstanding your point. -->

There are several compositional software interfaces which range from the highly complex and flexible to simple and limited designs. Viscosity - a measurement of the software's resistance to change - is not necessarily a negative attribute. Highly viscous software can present a user with a single, stable, well defined use-case. An example of this is *Wolfram Tones* [@Wolfram-Research-Labs:2011aa] which presents the user with a limited control set as a 'black box' [@Rosenberg:1982aa]. Another example is *Improviser for Audiocubes* [@Percussa:2012aa], in which the complexity of the performance is generated by the physical layout of the Audiocubes [@Percussa:2013aa]. As a result, keeping the sequencing interface simple avoids over-complicating the composition and performance processes. This simplicity, however, increases the viscosity and arguably limits compositional opportunity.

<!--
Many of the text-oriented languages used in the domain, such as *Impromptu* [@Sorensen:2010aa] and *SuperCollider* [@McCartney:2014aa], are abstraction-hungry. They frequently also have a high abstraction barrier as they require the user to learn the syntax and abstractions used. An example of abstraction-tolerant software is the *Algorithmic Composition Toolbox* by Paul Berg [-@Berg:2012aa], which presents objects to the user and allows the creation of new abstractions. The software makes use of musical metaphors (such as a rudimentary piano roll) for some elements. The user defines objects such as sections, shapes, masks and note structures which the program's 'generators' use to create new material. Some algorithmic composition tools do not require the user to interact with the method of generation; these are systems without abstraction capability. Robert Walker's *Fractal Tune Smithy* [-@Walker:2011aa] and Jonathan Middleton's *Musical Algorithms* [-@Middleton:2004aa] both require musical input which is then acted on using algorithms which are both hidden from, and inaccessible to, the user. A high level of abstraction can result in low visibility. An effective design would be for the software to have a low abstraction barrier but be abstraction-tolerant. Such a design would allow new users to work with the language without writing new abstractions, while more advanced users could write abstractions when appropriate.
-->

The text-oriented systems under review exhibit poor discriminability due to easily confused syntax, which invites error [@Blackwell:2003aa]. For example, Thomas Schürger's *SoundHelix* [-@Schurger:2012aa] produces code with a large number of XML tags, potentially reducing human readability and increasing the time taken to write the commands. Such a system increases the error-proneness of the system (whether the notation used invites mistakes). Issues of this type can be ameliorated by the syntax checking seen in the Post windows of *SuperCollider* and *Pure Data*, in which errors are outlined in a limited way. A more thorough error-checking system would be a significant improvement in the software's usability. *SuperCollider 3.6* introduced an IDE (Integrated Development Environment) based design, including autocompletion of class and method names. Such a system significantly reduces errors introduced by mistyping.

There are several music metaphors used in the software in this domain which require the user to be conversant in music theory. *Harmony Improvisator* [@Synleor:2013aa] requires input in the form of scales, chords and inversions. *Noatikl* [@Intermorphic:2012aa] uses abstractions to create what it refers to as 'Rule Objects' ('Scale Rule', 'Harmony Rule', 'Next Note Rule' and 'Rhythm Rule') to control how the software generates patterns. The *Algorithmic Composition Toolbox* [@Berg:2012aa] makes reference to note patterns and structures. Roger Dannenberg has explained how staff notation is rich in abstractions [-@Dannenberg:1993aa]; software which uses elements of staff notation is building abstractions on top of abstractions. An example of a consistent design is *Mixikl* [@Intermorphic:2013aa]. The design language refers metaphorically to both hardware synthesisers (the use of photorealistic rotary potentiometers and faders) and patching (patch cables which 'droop' as physical cables do). *Fractal Tune Smithy* [@Walker:2011aa] makes use of a less consistent design language. The design makes use of notation, piano roll, hardware-style controls, text-based data entry and window and card metaphors. The software is, as a result, highly capable of a wide variety of tasks but potentially at the expense of usability. There can also be consistency issues when software does not use standard operating system dialogue boxes. An example is *SuperCollider*'s save dialogue [@McCartney:2014aa], in which the 'Save' button is moved from the far right (the OS standard) to the far left. This is a clear example of poor consistency which could lead to unintended user error.


# Summary

There are opportunities for future work to consider the design of structurally-aware algorithmic composition software. It would be interesting to further employ Cognitive Dimensions in suggesting concrete improvements to the design of the software under review. A full review of time with reference to the CDN using the format suggested by @Blackwell:2001aa would be a useful process. The CDN is an evolving body of work and there are several new dimensions which could be utilised in future work in the area.

The issue of time raises particular questions. Algorithmic composition tools use varied interaction designs, and may promiscuously mix diverse elements from different musical, algorithmic and interaction approaches. Consequently, such tools can raise challenging design issues in the compositional representations of time. To some degree, these issues parallel similar issues in general programming, for example concerning sequence, looping, hierarchy and parallel streams. However, growing knowledge about how people perceive and process different kinds of musical structure at different time scales suggests that the design of algorithmic composition tools may pose a range of interesting new design issues. We hope that this paper has made a start in identifying opportunities to create or extend design tools to deal better with these challenging issues.
 



# References
